#
# Flip surface mesh creation scene, note - repeatedly plays back meshes in UI mode
# 
from manta import *
import os
   
print("\nNote - this scene reads in particle data generated by flip02_surface.py (un-comment line 120 there). It does not perform any fluid simulation, only generates a nicer surface.\n")


# === surface generation parameters ===

# input file 
partfile = 'flipParts_%04d.uni' 

# output file name so that blender can directly read it...
meshfile = 'fluidsurface_final_%04d.bobj.gz' 

# resolution for level set / output mesh
res = 128 
s = Solver(name='main', gridSize = vec3(res,res,res) , dim=3)

# kernel radius for surface creation
radiusFactor = 2.5

# triangle scale relative to cell size
scale = 0.5


# === scene setup ===

# prepare grids and particles
flags    = s.create(FlagGrid)
phi      = s.create(LevelsetGrid)
pp       = s.create(BasicParticleSystem) 
mesh     = s.create(Mesh)

# acceleration data for particle nbs
pindex = s.create(ParticleIndexSystem) 
gpi    = s.create(IntGrid)

# scene setup
flags.initDomain(boundaryWidth=0)
	
if 1 and (GUI):
	gui = Gui()
	gui.show()
	#gui.pause()

# for debugging:
#setDebugLevel(10) # full output

#main loop
tOut = 0
while tOut < 999:
	# for testing, optionally skip some input frames...
	tIn = tOut * 1

	meshfileCurr = meshfile % tOut 
	print("frame %d " % tIn)

	# already exists?
	if (os.path.isfile( meshfileCurr )):
		mesh.load( meshfileCurr )

	else:
		# generate mesh; first read input sim particles
		currParts = (partfile % tIn)
		if (os.path.isfile( currParts )):
			pp.load( currParts )
			
			# create surface
			gridParticleIndex( parts=pp , flags=flags, indexSys=pindex, index=gpi )
			#unionParticleLevelset( pp, pindex, flags, gpi, phi , radiusFactor ) # faster, but not as smooth
			averagedParticleLevelset( pp, pindex, flags, gpi, phi , radiusFactor , 1, 1 ) 

			phi.setBound(value=0., boundaryWidth=1)
			phi.createMesh(mesh)

			# beautify mesh, too slow right now!
			#subdivideMesh(mesh=mesh, minAngle=0.01, minLength=scale, maxLength=3*scale, cutTubes=False) 
			# perform smoothing
			#for iters in range(10):
				#smoothMesh(mesh=mesh, strength=1e-3, steps=10) 
				#subdivideMesh(mesh=mesh, minAngle=0.01, minLength=scale, maxLength=3*scale, cutTubes=True)

			# write output file:
			mesh.save( meshfileCurr )
		else:
			print("File '%s' not found, pausing" % currParts )

			# stop playback for UI, reset
			if (GUI):
				gui.pause()
				tOut = 0
		
	tOut += 1
	s.step()
	

